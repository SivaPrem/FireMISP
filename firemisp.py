# FireStic - Python script for indexing FireEye json alerts
# into Elasticsearch over http...and some alerting too
#
# Please see: https://github.com/spcampbell/firestic
#
from datetime import datetime
#from elasticsearch import Elasticsearch
from BaseHTTPServer import HTTPServer
from BaseHTTPServer import BaseHTTPRequestHandler
from SocketServer import ThreadingMixIn
import threading
import json
import logging
import socket
import firestic_alert
import fsconfig
import socket
import ConfigParser
from pymisp import PyMISP



config = ConfigParser.RawConfigParser()
config.read('config.cfg')

# set config values
misp_url = config.get('MISP', 'misp_url')
misp_key = config.get('MISP', 'misp_key')
misp_verifycert = config.getboolean('MISP', 'misp_verifycert')






#init logger
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')


def init_misp(url, key):
    return PyMISP(url, key, misp_verifycert, 'json')


class MyRequestHandler(BaseHTTPRequestHandler):

    # ---------- GET handler to check if httpserver up ----------
    def do_GET(self):
        pingresponse = {"name": "Firestic is up"}
        if self.path == "/ping":
            self.send_response(200)
            self.send_header("Content-type:", "text/html")
            self.wfile.write("\n")
            json.dump(pingresponse, self.wfile)

    # -------------- POST handler: where the magic happens --------------
    def do_POST(self):
        # get the posted data and remove newlines
        data = self.rfile.read(int(self.headers.getheader('Content-Length')))
        clean = data.replace('\n', '')
        theJson = json.loads(clean)

        self.send_response(200)
        self.end_headers()

        # deal with multiple alerts embedded as an array
        if isinstance(theJson['alert'], list):
#            alertJson = theJson
#            del alertJson['alert']
            for element in theJson['alert']:
                alertJson = {}  # added for Issue #4
                alertJson['alert'] = element
                logger.info("Processing FireEye Alert: " + str(alertJson['alert']['id']))
                processAlert(alertJson)
        else:
            logger.debug("Processing FireEye Alert: " + str(theJson['alert']['id']))
            #processAlert(theJson)

# ---------------- end class MyRequestHandler ----------------


# ---------------- Class handles requests in a separate thread. ----------------

class ThreadedHTTPServer(ThreadingMixIn, HTTPServer):
	pass

# ---------------- end class ThreadedHTTPServer ----------------

def searchall(m, search, quiet, url, out=None):
    result = m.search_all(search)
    if quiet:
        for e in result['response']:
            print('{}{}{}\n'.format(url, '/events/view/', e['Event']['id']))
    elif out is None:
        for e in result['response']:
            print(json.dumps(e) + '\n')
    else:
        with open(out, 'w') as f:
            for e in result['response']:
                f.write(json.dumps(e) + '\n')



def processAlert(theJson):

    # create a MISP event
    logger.debug(theJson)

    #check if event already exists

    result = misp.search_all(str(theJson['alert']['id']))
    logger.debug(json.dumps(result))
    if result['message']!= 'No matches.':
        logger.error("event already there")
        return False


    #event = misp.new_event(0, args.threat, args.analysis, args.info)

    #searchall(misp, str(theJson['alert']['id']), False, misp)

    event = misp.new_event(0, 1, 0, "Auto generated by FireMisp "+str(theJson['alert']['id']))

    logger.debug(event)

    #to
    victim=theJson['alert']['dst']['smtpTo']
    misp.add_email_dst(event,victim)

    #from
    attacker = theJson['alert']['src']['smtpMailFrom']
    misp.add_email_src(event,attacker)

    #subject
    subject = theJson['alert']['smtpMessage']['subject']
    misp.add_email_subject(event, attacker)



    malware_md5 = theJson['alert']['explanation']['malwareDetected']['malware'][0]['md5Sum']
    malware_name = theJson['alert']['explanation']['malwareDetected']['malware'][0]['name']
    misp.add_hashes(event,None,malware_name,malware_md5,None,None,None,"Detected by FireEye",True,None,False)





    # ---------- add geoip information ----------
    alertInfo = {}
    alertInfo['srcIp'] = theJson['alert'].setdefault('src', {}).setdefault(u'ip', u'0.0.0.0')
    alertInfo['dstIp'] = theJson['alert'].setdefault('dst', {}).setdefault(u'ip', u'0.0.0.0')

    alertInfo['type'] = theJson['alert']['name']
    if alertInfo['type'] == 'ips-event':
        alertInfo['mode'] = theJson['alert']['explanation']['ips-detected']['attack-mode']

    logger.debug(alertInfo)



    #theJson['alert']['src']['geoip'] = geoInfo['src']
    #theJson['alert']['dst']['geoip'] = geoInfo['dst']

    # ---------- add @timestamp ----------
    # use alert.occurred for timestamp. It is different for IPS vs other alerts
    # ips-event alert.occurred format: 2014-12-11T03:28:08Z
    # all other alert.occurred format: 2014-12-11 03:28:33+00
    logger.debug("Alert name "+ theJson['alert']['name'])
    '''if theJson['alert']['name'] == 'ips-event':
        timeFormat = '%Y-%m-%dT%H:%M:%SZ'
        oc = datetime.strptime(theJson['alert']['occurred'], timeFormat)

    elif theJson['alert']['name'] == 'MALWARE_OBJECT':
        import datetime
        dat2e = (theJson['alert']['occurred'])
        t = datetime.datetime.fromtimestamp(float(dat2e) / 1000.)

        fmt = "%Y-%m-%d %H:%M:%S"
        logger.debug(t.strftime(fmt))

        timeFormat = '%Y-%m-%d %H:%M:%S'
        oc = datetime.strptime('2016-03-24 16:09:51', timeFormat)

    else:
        timeFormat = '%Y-%m-%d %H:%M:%S+00'
        oc = datetime.strptime(theJson['alert']['occurred'], timeFormat)
    '''

    # Append YYYY.MM.DD to indexname like Logstash

    #esIndexStamped = fsconfig.esIndex + oc.strftime('-%Y.%m.%d')
    # Put the formatted time into @timestamp
    #theJson['@timestamp'] = oc.strftime('%Y-%m-%dT%H:%M:%S.%fZ')

    # ---------- Remove alert.explanation.os-changes ----------
    # TODO: figure out a way to incorporate this info.
    # Doing this is complicated. Will require creative
    # Elasticsearch mapping (template?). Need to gather more json examples.
    # UPDATE -- For now, we will extract a few key bits of information from
    #           os-changes: Operating system(s) targeted, application(s) targeted,
    #           malicious activity found and listed in 'malicious-alert'.
    if 'os-changes' in theJson['alert']['explanation']:
        # Go extract some useful data to include in alert
        theJson['alert']['explanation']['summaryinfo'] = getSummaryInfo(theJson['alert']['explanation']['os-changes'])
        # DEV: save the os-changes field to file for later review
        with open('oschanges.json', 'a') as outfile:
            fileData = 'TIMESTAMP: ' + theJson['@timestamp'] + ' - '
            fileData += theJson['alert']['name'] + ' - '
            fileData += theJson['alert']['id'] + '\n'
            fileData += json.dumps(theJson['alert']['explanation']['os-changes'])
            fileData += '\n--------------------\n\n'
            outfile.write(fileData)
        del theJson['alert']['explanation']['os-changes']
        logger.debug("[os-changes] deleted")

    # ---------- Index data into Elasticsearch ----------
    try:
        #TODO: here is the real upload of the stuff


        #TODO: before upload check if it is already there and do not add another event, maybe a sighting would be enouhj
        logger.debug(json.dumps(theJson, sort_keys=True,indent=4, separators=(',', ': ')))
        '''
        es.index(index=esIndexStamped,
                 doc_type=theJson['alert']['name'], body=theJson)
                 '''
    except:
        logText = "\n-----------\nES POST ERROR\n-----------\nJSON: "
        logText += json.dumps(theJson) + "\n"
        # logText += "TIME: " + datetime.utcnow() + "\n"
        logging.exception(logText)





def getSummaryInfo(oschanges):
    summaryInfo = []
    if isinstance(oschanges,list):
        for instance in oschanges:
            thisInfo = {}
            thisInfo['osinfo'] = instance['osinfo']
            thisInfo['app-name'] = instance['application']['app-name']
            thisInfo['malicious-alert'] = []
            if ('malicious-alert' in instance):
                for eachma in instance['malicious-alert']:
                    thisInfo['malicious-alert'].append(eachma)
            summaryInfo.append(thisInfo)
    else:
        thisInfo = {}
        thisInfo['osinfo'] = oschanges['osinfo']
        thisInfo['app-name'] = oschanges['application']['app-name']
        thisInfo['malicious-alert'] = []
        if ('malicious-alert' in oschanges):
            for eachma in oschanges['malicious-alert']:
                thisInfo['malicious-alert'].append(eachma)
        summaryInfo.append(thisInfo)

    return summaryInfo

def getHostname(ipaddress):
    try:
        lu = socket.gethostbyaddr(ipaddress)
        return lu[0]
    except:
        return None




def main():
    server = ThreadedHTTPServer((fsconfig.httpServerIP, fsconfig.httpServerPort), \
									MyRequestHandler)

    logger.info("Starting HTTP server %s %s",fsconfig.httpServerIP,fsconfig.httpServerPort)
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        logger.error("HTTP Server stopped")


if __name__ == "__main__":
    #es = Elasticsearch()
    misp = init_misp(misp_url, misp_key)

    #misp.sighting_per_json("testing/sighting.json")

    logging.basicConfig(level=logging.WARNING,
                        filename=fsconfig.logFile,
                        format='%(asctime)s - %(levelname)s - %(message)s')
    main()
